# Начинаем писать CSS

Вам не кажется что CSS уже не такой как раньше? Последние несколько лет это 
актуальная тема для множества умных людей. CSS — это не просто звено, которое 
фронтенд-разработчик должен добавить чтобы страница выглядела красиво. Это 
намного больше. Производительность для нас играет большую роль и мы стремимся 
разрабатывать хорошие вебсайты. В этой статье я хочу поделиться опытом, 
приобретённым за последние несколько месяцев и моими взглядами на написание 
CSS-кода. Меня как программиста очень интересует архитектурная часть процесса. 
Мне кажется что процесс написания CSS нуждается в изменениях и я усердно изучаю 
этот вопрос. Я веду поиск удачных подходов и методов, новых вариантов 
организации процесса написания кода. Эта статья является своеобразным итогом 
путешествия в мир CSS. Многие говорят что написание CSS — это не совсем 
программирование. Я с этим не согласен и считаю что оно не менее интересно и 
сложно.

## Препроцессоры CSS

![Препроцессоры][Что происходит когда программист начинает писать CSS — 1]

Взглянем правде в лицо. Написание чистого CSS — не самое увлекательное занятие в 
мире. Препроцессоры берут нечто напоминающее CSS и чудесным образом выдают 
валидный CSS-код. Это добавляет дополнительную прослойку между разработчиком и 
конечным стилем, который будет послан браузеру. Однако всё не так плохо, ведь 
препроцессоры обладают некоторыми очень полезными возможностями.

### Конкатенация

Наиболее ценной возможностью препроцессоров я считаю конкатенацию файлов. Уверен, 
вы знаете что написав `@import` в файле `.css` вы собственно говорите браузеру: 
*«используй и этот файл, пожалуйста»*. И он его использует. Добавляется еще один 
запрос, что не очень хорошо, ведь таких файлов у вас может быть много. Большое 
количество запросов ухудшает производительность приложения. Если использовать 
препроцессоры CSS, эта проблема устраняется. Они просто объединяют все стили в 
один файл `.css`.

### Расширение

Есть два основных препроцессора CSS — [LESS][1] и [SASS][2]. Они оба 
поддерживают расширение CSS. Да, работают они немного по-разному, но идея та же. 
Вы создаете базовый класс (его обычно называют «миксин») с набором свойств и 
затем импортируете эти свойства в другой селектор. Например:

    // less
    .bordered(@color: #000) {
        border: dotted 2px @color;
    }
    .header { .bordered; }
    .footer { .bordered(#BADA55); }
    
    // компилируется в
    .header {
        border: dotted 2px #000000;
    }
    .footer {
        border: dotted 2px #bada55;
    }

Здесь есть нюанс: если вы прописываете миксин без аргумента, т.е. если у вас 
есть только 

    .bordered {
        border: dotted 2px #000;
    }

он целиком добавляется в скомпилированный файл CSS, вне зависимости от того 
используется он или нет. Это происходит потому что он является валидным 
селектором. SASS даёт немного больше гибкости за счёт миксинов, расширений и 
заполнителей (если вас интересует в чём между ними разница, очень советую 
прочитать [эту статью][3]). Давайте рассмотрим следующий SASS и его компиляцию:

    // sass
    @mixin bordered($color: #000) {
        border: dotted 2px $color;
    }
    .header { @include bordered; }
    .footer { @include bordered(#BADA55); }

    // компилируется в
    .header {
        border: dotted 2px black; 
    }
    .footer {
        border: dotted 2px #bada55; 
    }

Выглядит почти так же. Но если перейти к второму варианту использования и 
определить заполнитель:

    // sass
    %bordered {
        border: dotted 2px #000;
    }
    .header { 
        @extend %bordered; 
    }
    .footer { 
        @extend %bordered; 
    }

    // компилируется в
    .header, .footer {
        border: dotted 2px #000; 
    }

Очевидны два позитивных момента. Во-первых, класс `.bordered` не компилируется. 
Во-вторых, SASS комбинирует селекторы, что делает CSS немного короче. 

### Компоновка

LESS и SASS поддерживают определение переменных. Можно в любой момент обратиться 
к этим переменным и использовать их в качестве значений для свойств.

    // sass
    $brand-color: #009f0A;
    …
    h1 {
        color: $brand-color;
    }

Это удобная функция, поскольку она позволяет сохранять важные данные вроде 
цветов компании или ширину сетки в одном месте. Если вам нужно что-то изменить, 
не придётся просматривать весь код.

Также удобно использовать переменные когда нужно сделать вставку. Это 
продемонстрировано в следующем примере:

    // sass
    @mixin border($side) {
        border-#{$side}: solid 1px #000;
    }
    .header {
        @include border("left");
    }
    
    // компилируется в
    .header {
        border-left: solid 1px #000; 
    }

### Аргументы против препроцессоров

* Препроцессор является инструментом, т.е. это еще один компонент, который вам 
придётся добавить в среду разработки. Вам возможно захочется сделать его 
встроенным в приложение. Это, само собой, предусматривает написание 
дополнительного кода.
* Если вы не хотите беспорядка в коде, вам вероятно понадобится средство 
отслеживания изменений. Еще один инструмент, который будет следить за вашими 
файлами и запускать компиляцию после того как в них будут внесены изменения. 
Если это ваш случай, вам придётся запускать этот инструмент каждый раз когда вы 
начинаете работать над проектом. Возможно, со временем вы найдете способ 
оптимизировать этот процесс, но над этим придётся поработать.
* Очень часто разработчиков заботят только файлы .less или .sass. Однако, 
результат — вот что действительно имеет значение. Ваш SASS может быть изящным и 
оптимизированным, однако это не гарантирует что в результате вы получите столь 
же красивый CSS. Могут возникнуть довольно *интересные* проблемы со 
специфичностью. Так что скомпилированную версию нужно регулярно просматривать.

## БЭМ

![БЭМ][Что происходит когда программист начинает писать CSS — 2]

Вот еще один инструмент с которым можно поиграть. Возможно препроцессоры и 
экономят кучу времени, но только с их помощью хорошую архитектуру не построишь. 
Первое о чём я задумался — это выбор названий. Рассмотрим следующую 
HTML-разметку:

    <header class="site-header">
        <div class="logo"></div>
        <div class="navigation"></div>
    </header>

Стили могут быть такими:

    .site-header { … }
    .logo { … }
    .navigation { … }

Такой код, конечно же, будет работать, однако есть проблема: читая CSS вы не 
сможете понять что, например, логотип `logo` является частью шапки `header`. Еще 
один маленький логотип может быть использован в подвале. Следующий логичный шаг — 
прописать в селекторе элемент-родитель. 

    .site-header .logo { … }

Однако это не очень хорошая идея, ведь стили становятся зависимыми от иерархии 
конкретных тегов. Что если потребуется перенести логотип за пределы тега 
`header`? Стиль не будет применён. Можно добавить `site-header` в название 
класса логотипа:

.site-header-logo { … }

Код хорош и понятен, однако такой подход не всегда работает. Позже, в январе, я 
может быть захочу использовать рождественскую версию логотипа. Но я не смогу 
написать

    .site-header-logo-xmas { … }

потому что по логике название селектора должно отвечать расположению тегов в 
HTML.

[БЭМ][4] может стать решением в таком случае. Он расшифровывается как «Блок, 
элемент, модификатор» и диктует некоторые правила, которым нужно следовать. 
Используя БЭМ можно превратить наш маленький пример в:

    .site-header { … } /* блок */
    .site-header__logo { … } /* элемент */
    .site-header__logo--xmas { … } /* модификатор */
    .site-header__navigation { … } /* элемент */

Т.е. `site-header` — это у нас блок. Логотип `logo` и навигация `navigation` — 
элементы этого блока, а версия логотипа `xmas` — модификатор. Возможно всё и 
выглядит очень просто, но такой подход даёт широкие возможности. Начав его 
использовать, вы убедитесь что архитектура ваших работ улучшится. Слабой 
стороной БЭМ является разве что синтаксис. Да, он немного безобразен, но я готов 
пойти на жертвы ради исправности системы.

(материалы для чтения: [здесь][5] и [здесь][6])

## OOCSS

![OOCSS][Что происходит когда программист начинает писать CSS — 3]

Открыв для себя БЭМ, я научился правильно называть классы и задумался над 
структурой. Наверное первой мне на глаза попалась статья об 
[Объектно-ориентированном CSS][7]. Суть объектно-ориентированного 
программирования частично заключается в использовании абстракций и язык CSS их 
поддерживает. Не важно используете вы препроцессоры или нет, вам нужно знать об 
OOCSS. Я программист, поэтому эта концепция показалась мне очень похожей на то, 
как я программирую каждый день, например, на JavaScript. У неё есть два главных 
принципа:

### Разделение структуры и оформления

Взгляните на следующий пример:

    .header {
        background: #BADA55;
        color: #000;
        width: 960px;
        margin: 0 auto;
    }
    .footer {
        background: #BADA55;
        text-align: center;
        color: #000;
        padding-top: 20px;
    }

В нём несколько стилей продублированы. Их можно выделить в отдельный класс 
следующим образом:

    .colors-skin {
        background: #BADA55;
        color: #000;
    }
    .header {
        width: 960px;
        margin: 0 auto;
    }
    .footer {
        text-align: center;
        padding-top: 20px;
    }

Теперь у нас есть объект `colors-skin`, которому можно найти широкое применение. 
Разметка html может выглядеть так:

    <div class="header colors-skin"> … </div>
    <div class="colors-skin"> … </div>
    <div class="footer colors-skin"> … </div>

У такого изменения есть несколько плюсов:

* Мы получаем класс, который можно использовать несколько раз. 
* Если нужно внести изменение, это нужно сделать только для одного класса.
* Повторение в файле CSS удалено, что делает размер файла меньшим. 

### Разделение контейнера и содержимого

Здесь суть в том, чтобы у каждого элемента был один и тот же стиль вне 
зависимости от его расположения. Это значит что следует избегать использования 
селекторов вроде следующего:

    .header .social-widget {
        width: 250px;
    }

Ведь если переместить `.social-widget` за пределы контейнера `.header`, его 
ширина изменится. В общем, так делать не рекомендуется. Особенно для компонентов, 
которые встречаются по всей странице. Это принцип блочного CSS и я настоятельно 
рекомендую выделить немного времени на то, чтобы попробовать такой подход. Лично 
мне следование этому принципу помогает писать лучший CSS.

### Фреймворк

Если вы откроете [репозиторий OOCSS][8] на GitHub, то увидите фреймворк. Да, в 
этом фреймворке используется концепция объектно-ориентированного CSS и да, у 
него есть несколько крутых компонентов, готовых к использованию. С некоторого 
времени мне не нравятся фреймворки. Если вы на минуту задумаетесь, то увидите 
что слово фреймворк состоит из двух частей — «frame» и «work», что значит 
«каркас, рамка»<a href="#note-1" class="reference">1</a> и «изделие». И 
действительно, работая с фреймворком вы ограничены рамками. Вы связались с этим 
инструментом и вынуждены играть по его правилам. Я отдаю предпочтение 
микро-фреймворкам или подобным инструментам, которые дают мне лишь основу. Я ни 
в коем случае не пытаюсь изобрести колесо, только хочу найти баланс. Очень часто 
готовые к использованию решения ведут к неопрятной и слишком запутанной системе. 
Я бы советовал создавать такие инструменты с одной конкретной целью. Если 
пытаться предвидеть побольше способов применения, в результате получите… ну, вы 
поняли — фреймворк. 

Тем не менее я настоятельно рекомендую взглянуть на фреймворк OOCSS. Возможно он 
подойдёт под ваши требования. Создатель репозитория — [Николь Саливан (Nicole 
Sullivan)][9]. Она первооткрыватель OOCSS и если у вас появится немного 
свободного времени, советую послушать её [презентации/лекции][10].

## SMACSS

![SMACSS][Что происходит когда программист начинает писать CSS — 4]

Представляю вам ещё одну популярную концепцию: [SMACSS][11]. SMACSS 
расшифровывается как масштабируемая модульная архитектура css (scalable and 
modular architecture for CSS). [Джонатан Снук (Jonathan Snook)][12] предложил 
нечто вроде гида по стилю для CSS-разработчиков. Суть в том чтобы разделить ваше 
приложение на следующие категории:

* Основа — базовые стили по умолчанию для простых селекторов. Например, 
`clearfix`. 
* Структура — определение каркаса.
* Модуль — группа элементов которые вместе формируют модуль. Например, шапка или 
боковая колонка.
* Состояние — содержит описание различных состояний элементов. Правила при 
скрытии, нажатии, растяжении (и т.д.) определённого объекта.
* Тема — большей мерой определение визуального представления элементов. Похожая 
на категорию «состояние».

Мне пока не приходилось использовать концепцию SMACSS, но она довольно популярна 
и действительно продвигает хорошие идеи. Больше всего радует что она скорее 
является идеей реализации чем фреймворком. Следовательно, вы не связаны чёткими 
правилами, классами или компонентами.

## Атомный дизайн

![Атомный][Что происходит когда программист начинает писать CSS — 5]

Изучив OOCSS и SMACSS, я начал искать подходящее модельное представление и 
довольно быстро оказался на этой [странице][13]. Это презентация отличной 
концепции *«Атомный дизайн»*. Её автор — [Бред Фрост (Brad Frost)][14], 
известный веб-разработчик, работающий преимущественно в мире [отзывчивого 
дизайна][15] и дизайна для мобильных устройств. 

Идея очень интересна. Используя терминологию химии, можно сказать что базовой 
составляющей материи является атом. Бред переносит это в CSS и утверждает что 
наши страницы построены из атомов. Атомом может быть 

    <label>Поиск по сайту</label>

или

    <input type="text" placeholder="введите ключевое слово" />

Т.е. атомы содержат базовые стили элементов DOM. Например, цветовую палитру, 
размеры шрифтов или переходы. Затем эти частички можно объединить в молекулы. 
Например:

    <form>
        <label>Поиск по сайту</label>
        <input type="text" placeholder="введите ключевое слово" />
        <input type="submit" value="Поиск" />
    </form>

Элемент `form` состоит из нескольких атомов. Абстрагируясь таким образом, мы 
получаем большую гибкость, ведь можно использовать те же атомы чтобы построить 
другую молекулу. Кроме того, ту же форму можно использовать в разных контекстах. 

На этом Бред не остановился. Молекулы объединяются в организмы. Следуя тому же 
подходу, можно прописать следующее и назвать его организмом:

    <header>
        <div class="logo">
        <nav>
            <ul>
                <li><a href="#">Домашняя страница</a></li>
                <li><a href="#">Общие сведения</a></li>
                <li><a href="#">Контакты</a></li>
            </ul>
        </nav>
        <form>
            <label>Поиск по сайту</label>
            <input type="text" placeholder="введите ключевое слово" />
            <input type="submit" value="поиск" />
        </form>
    </header>

Еще одна особенность концепции — заготовки. Они не имеют ничего общего с химией, 
однако вписываются в веб-контекст. Сочетая разные организмы, мы создаём 
заготовку. Затем из этих заготовок формируется конечная страница. 

Вы наверняка уже используете похожий подход к созданию приложений. Тем не менее, 
использование подходящих названий для вещей положительно влияет на архитектуру. 
В процессе разработки вам и вашим коллегам будет проще понять друг друга. 
Разделение составляющих разметки на атомы и молекулы важно, так как оно помогает 
наладить рабочий процесс и обслуживание вашего веб-приложения. 

## Органический CSS

![ОCSS][Что происходит когда программист начинает писать CSS — 6]

Пару месяцев назад я написал [статью][16] об [Organic][17]. Это чудесный 
маленький фреймворк для приложений на JavaScript. Он даже больше смахивает на 
шаблон разработки и лично мне он очень понравился. Я даже использовал Organic в 
нескольких проектах и всё работает без каких-либо проблем. Если он вас 
заинтересовал, советую почитать [этот пост][18]. 

Когда я натолкнулся на статью Бреда Фроста, мне уже была знакома похожая 
концепция, реализованная в Organic. Работа Бреда просто великолепна, однако я 
решил пойти дальше и написать собственный микро-фреймворк на основе концепции 
атомного дизайна. Я использовал SASS в качестве препроцессора и создал 
репозиторий на Github — [https://github.com/krasimir/organic-css][19].

### Атомы

Начнём с наименьшего компонента фреймворка — атома. Согласно определению из 
[википедии][20], *атом является наименьшей частицей вещества*. В контексте CSS, 
думаю этому определению соответствует свойство и его значение. Например:

    margin-top: 24px;

Добавление атомов посредством прописания стилей прямо в классах не соответствует 
моим намерениям. Потому что если я напишу что-то вроде этого:

    body {
        margin-top: 24px;
    }
    header {
        margin-top: 24px;   
    }

препроцессор оставит эту запись как есть. А мне нужен вот такой результат:

    body, header {
        margin-top: 24px;
    }

В SASS такого эффекта можно добиться используя заполнители. Т.е.

    %margin-top-24 {
        margin-top: 24px;
    }
    body {
        @extend %margin-top-24; 
    }
    header {
        @extend %margin-top-24; 
    }

Итак, мне пришлось использовать заполнители селекторов. Это также значит что мне 
потребовалось создать большое количество заполнителей, которые можно было бы 
использовать впоследствии. Я решил что фреймворк будет состоять только из атомов. 
И может быть нескольких молекул с функциями широкого применения вроде всем 
известного `reset.css`, определения сетки и т.п. Я хотел написать нечто, что 
могло бы служить основой для разработки CSS. Возможно в дальнейшем процессе 
работы над проектами я найду и какие-то заготовки, которые также можно будет 
предложить в качестве основы, но для начала я хотел сохранить репозиторий чистым 
и простым. 

Для большей последовательности работы я создал миксин для определения атома. 
Итак, вот пример:

    @include define-atom("block") {
        display: block;
    }
    @include define-atom("font-family") {
        font-family: Georgia;
    }

Используя этот подход я создал подборку атомов, которые можно с легкостью 
применить для любого проекта. Взглянуть на них можно [здесь][21]. Я использовал 
некоторые хорошие правила из других фреймворков, не всё является моей заслугой. 
Также доступен миксин для объединения атомов в молекулу:

    @mixin header { // <- молекула с названием 'header'
        @include atoms((
            block,
            clearfix,
            font-family
        ));
    }

### Молекулы

Молекула — это элемент DOM, который нужно стилизировать и у которого нет 
дочерних элементов. Или же если у него есть дочерние элементы, они напрямую с 
ним не связаны. Например, `<img src="logo.jpg" />` может быть молекулой. Если 
вам трудно определить молекулы у себя на странице, просто подумайте что 
построено из атомов. Если какой-то элемент построен из других молекул, это 
наверное органелла. Несколько строчек выше я показал как определить молекулу:

    @mixin login-box { 
        @include atoms((
            block,
            font-size-20,
            margin-top-23,
            bold
        ));
    }

Ко мне пришла одна интересная мысль. Рассмотрим тег `body`. Что это? Молекула 
или что-то другое? Он, без сомнения, нуждается в стилизации посредством атомов, 
но в общем содержит другие молекулы. Значит он должно быть не молекула, а что-то 
другое. Я пришёл к заключению что CSS должен быть на первом месте. Т.е. если для 
стилизации `body` нужны несколько атомов, значит он является молекулой, что 
значит что теоретически я не должен присоединять к нему никаких других молекул. 
Это может показаться непрактичным, но в большинстве случаев поможет вам 
воздержаться от использования дочерних селекторов, что хорошо.

### Органеллы

Как только вы разберётесь с тем какие элементы DOM являются молекулами, вы 
поймёте что такое органеллы. Например, обычный элемент `form` служит прекрасным 
примером органеллы. Он содержит молекулы `label`, `input` и `textarea`.

    .login-form {
        @include label;
        @include input;
        @include textarea;
    }

Органеллы — это наверное первая часть фреймворка, которая тесно связана с 
текущим приложением. Атомы и молекулы могут быть перенесены в другие проекты, в 
отличии от органелл.

### Больше абстракций

Очень часто вы можете захотеть объединить органеллы ещё во что-то. В таком 
случае добавим ещё абстракций.

    Атом → Молекула → Органелла → Клетка → Ткань → Орган → Система → Организм

Только от вас зависит как вы построите свой CSS. Пока я использовал OrganicCSS 
только в одном проекте, но могу сказать что он помогает внести в проект ясность. 
Я рассортировал разные элементы по разделам и дал классам такие названия чтобы с 
лёгкостью ориентироваться с чем я имею дело. Например, если у меня есть 
органелла с названием `header`, я просто изменю её название на `o-header`. 
Просматривая HTML-разметку спустя некоторое время, я сразу вижу что CSS-стили 
для этого элемента находятся в разделе «органеллы».

## Заключение

Это было интересное путешествие. Не знаю буду ли я использовать OrganicCSS в 
будущем, но это не самое главное. Главное чему я научился. Я понимал что мне 
нужно изменить свой подход к процессу разработки CSS и я это сделал. Мне кажется 
нужно больше говорить об архитектуре CSS. Как видите, для этого есть много 
хороших ресурсов. Их только нужно найти, понять как они работают и что с их 
помощью можно сделать. Только тогда можно выбирать что использовать а что нет. 
Даже больше того, когда видите целостную картину, вы получаете возможность 
придумать что-то, что будет больше соответствовать вашим потребностям. 

---

### Примечания

<a href="#note-1" id="note-1" class="reference">1</a> В английском языке слово 
«frame» имеет большое количество значений. Одно из них — «рамка» (напр. для 
картины или зеркала), его обыгрывает автор статьи в своём рассуждении о работе с 
фреймворком. 

[1]: http://lesscss.org/
[2]: http://sass-lang.com/
[3]: http://krasimirtsonev.com/blog/article/SASS-mixins-extends-and-placeholders-differences-use-cases
[4]: http://bem.info/method/definitions/
[5]: http://bem.info/method/definitions/
[6]: http://csswizardry.com/2013/01/mindbemding-getting-your-head-round-bem-syntax/
[7]: https://github.com/stubbornella/oocss/wiki
[8]: https://github.com/stubbornella/oocss
[9]: https://twitter.com/stubbornella
[10]: http://www.youtube.com/watch?v=GhX8iPcDSsI
[11]: http://smacss.com/
[12]: https://twitter.com/snookca
[13]: http://bradfrostweb.com/blog/post/atomic-web-design/
[14]: http://bradfrostweb.com/
[15]: http://bradfrost.github.io/this-is-responsive/index.html
[16]: http://net.tutsplus.com/tutorials/javascript-ajax/organic-development/
[17]: https://github.com/VarnaLab/node-organic
[18]: http://net.tutsplus.com/tutorials/javascript-ajax/organic-development/
[19]: https://github.com/krasimir/organic-css
[20]: http://ru.wikipedia.org/wiki/%D0%90%D1%82%D0%BE%D0%BC
[21]: https://github.com/krasimir/organic-css/tree/master/src/atoms

[Что происходит когда программист начинает писать CSS — 1]: img/preprocessors-ru.jpg
[Что происходит когда программист начинает писать CSS — 2]: img/bem-ru.jpg
[Что происходит когда программист начинает писать CSS — 3]: img/oocss-ru.jpg
[Что происходит когда программист начинает писать CSS — 4]: img/smacss-ru.jpg
[Что происходит когда программист начинает писать CSS — 5]: img/atomic-ru.jpg
[Что происходит когда программист начинает писать CSS — 6]: img/organic-ru.jpg